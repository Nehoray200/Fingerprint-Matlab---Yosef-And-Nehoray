% ========================================================================
% FILENAME: main_system.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab
% ========================================================================

%% ========================================================================
%% מערכת ביומטרית לזיהוי טביעת אצבע - main_system.m
%% ========================================================================
clc; clear; close all;

% --- 1. הגדרת נתיבים ---
addpath(genpath('src'));
addpath('data');         

% --- 2. הגדרות מערכת ---
cfg = get_config();
dbFileName = cfg.db_filename; 
PASS_THRESHOLD = cfg.match.pass_threshold;
minPointsEnroll = cfg.enroll.min_minutiae; 

% --- 3. ניהול זיכרון (Optimization) ---
% נחזיק את המאגר בזיכרון במקום לטעון אותו כל פעם מחדש
fingerprintDB = []; 
db_needs_reload = true; % דגל שמסמן אם צריך לטעון את המאגר מחדש

while true
    %% טעינת מאגר חכמה (רק אם צריך)
    if db_needs_reload && isfile(dbFileName)
        try
            loadedData = load(dbFileName, 'fingerprintDB');
            if isfield(loadedData, 'fingerprintDB')
                fingerprintDB = loadedData.fingerprintDB;
            else
                fingerprintDB = [];
            end
            db_needs_reload = false; % המאגר מעודכן, מכבים את הדגל
            disp('>> המאגר נטען/עודכן בהצלחה לזיכרון.');
        catch
            warning('שגיאה בטעינת קובץ המאגר.');
            fingerprintDB = [];
        end
    elseif ~isfile(dbFileName)
        fingerprintDB = [];
    end

    %% תפריט ראשי
    choice = menu('מערכת ביומטרית - תפריט ראשי', ...
                  '1. רישום משתמש בודד (Single Enrollment)', ...
                  '2. זיהוי משתמש בודד (Single Identification)', ...
                  '3. רישום המוני (Batch Enrollment)', ...
                  '4. זיהוי המוני + סטטיסטיקה (Batch Identification)', ...
                  '5. הצגת המאגר', ...
                  '6. יציאה');
              
    if choice == 6 || choice == 0
        disp('יציאה מהמערכת.');
        break;
    end
    
    %% משתנים לשימוש
    currentData = []; 
    currentImg = [];
    fullPath = '';
    
    %% --- טיפול במקרים 1 ו-2 (קבצים בודדים) ---
    if choice == 1 || choice == 2
        [file, path] = uigetfile({'*.tif;*.png;*.jpg;*.bmp', 'Fingerprint Files'}, ...
                                 'בחר תמונת טביעת אצבע', 'data/');
        
        if isequal(file, 0), continue; end 
        
        fullPath = fullfile(path, file);
        try
            currentImg = imread(fullPath);
            disp('>> מעבד תמונה...');
            % שימוש בפונקציה המאוחדת החדשה
            [template, ~, ~, descriptors] = process_fingerprint(currentImg); 
            
            if size(template, 1) < minPointsEnroll
                msgbox(sprintf('איכות נמוכה: %d נקודות (דרוש %d).', size(template, 1), minPointsEnroll), 'שגיאה', 'error');
                continue;
            end
            
            currentData.minutiae = template;
            currentData.descriptors = descriptors;
            
        catch err
            errordlg(['שגיאה בעיבוד הקובץ: ' err.message]);
            continue;
        end
    end
    
    %% --- לוגיקה לפי בחירה ---
    switch choice
        
        % === 1. רישום בודד ===
        case 1
            name = inputdlg('הכנס שם משתמש:', 'רישום');
            if ~isempty(name) && ~isempty(name{1})
                add_user_to_db(dbFileName, name{1}, currentData, fullPath);
                
                % עדכון הדגל: ביצענו שינוי בדיסק, צריך לטעון מחדש בסיבוב הבא
                db_needs_reload = true; 
            end
            
        % === 2. זיהוי בודד ===
        case 2
            if isempty(fingerprintDB)
                msgbox('המאגר ריק או לא נטען.', 'שגיאה', 'error'); continue;
            end
            % כאן לא עושים load, משתמשים ב-fingerprintDB מהזיכרון
            
            bestScore = 0;
            bestName = 'לא ידוע';
            bestAlignedPoints = [];
            bestDbTemplate = [];
            
            wb = waitbar(0, 'סורק מאגר...');
            for i = 1:length(fingerprintDB)
                waitbar(i/length(fingerprintDB), wb);
                
                dbData.minutiae = fingerprintDB(i).template;
                if isfield(fingerprintDB(i), 'descriptors')
                    dbData.descriptors = fingerprintDB(i).descriptors;
                else, dbData.descriptors = []; end
                
                [score, alignedData, ~] = find_best_match(dbData, currentData, 0);
                
                if score > bestScore
                    bestScore = score;
                    bestName = fingerprintDB(i).name;
                    bestAlignedPoints = alignedData;
                    bestDbTemplate = fingerprintDB(i).template;
                end
            end
            close(wb);
            
            if bestScore >= PASS_THRESHOLD
                msgbox(['זוהה: ' bestName ' (ציון: ' num2str(bestScore) ')'], 'הצלחה');
                visualize_match_result(currentImg, bestDbTemplate, bestAlignedPoints, bestName, bestScore);
            else
                msgbox(['לא נמצאה התאמה. ציון הכי גבוה: ' num2str(bestScore)], 'כישלון', 'error');
            end
            
        % === 3. רישום המוני ===
        case 3
            [files, path] = uigetfile({'*.tif;*.png;*.jpg;*.bmp', 'Fingerprint Files'}, ...
                                      'בחר תמונות לרישום', 'data/', 'MultiSelect', 'on');
            if isequal(files, 0), continue; end
            if ischar(files), files = {files}; end
            
            wb = waitbar(0, 'מבצע רישום המוני...');
            successCount = 0;
            for k = 1:length(files)
                waitbar(k/length(files), wb, sprintf('רושם: %s...', files{k}));
                fullPath = fullfile(path, files{k});
                try
                    img = imread(fullPath);
                    [template, ~, ~, descriptors] = process_fingerprint(img);
                    
                    if size(template, 1) >= minPointsEnroll
                        [~, nameByUser, ~] = fileparts(files{k});
                        tempData.minutiae = template;
                        tempData.descriptors = descriptors;
                        add_user_to_db(dbFileName, nameByUser, tempData, fullPath);
                        successCount = successCount + 1;
                    end
                catch, end
            end
            close(wb);
            msgbox(['נוספו ' num2str(successCount) ' משתמשים.'], 'סיום');
            
            % עדכון הדגל: המאגר בדיסק השתנה
            db_needs_reload = true;

        % === 4. זיהוי המוני + חישוב אחוזי הצלחה ===
        case 4
            if isempty(fingerprintDB)
                msgbox('המאגר ריק או לא נטען.', 'שגיאה', 'error'); continue;
            end
            % כאן לא עושים load, חוסכים זמן רב!
            
            [files, path] = uigetfile({'*.tif;*.png;*.jpg;*.bmp', 'Fingerprint Files'}, ...
                                      'בחר תמונות לבדיקה', 'data/', 'MultiSelect', 'on');
            if isequal(files, 0), continue; end
            if ischar(files), files = {files}; end
            
            results = {}; 
            wb = waitbar(0, 'מבצע זיהוי המוני...');
            
            correctCount = 0;
            validCount = 0; 
            
            for k = 1:length(files)
                waitbar(k/length(files), wb, sprintf('בודק: %s...', files{k}));
                thisFile = files{k};
                fullPath = fullfile(path, thisFile);
                
                % --- חילוץ "הזהות האמיתית" משם הקובץ ---
                [~, fNameNoExt, ~] = fileparts(thisFile);
                parts = strsplit(fNameNoExt, '_');
                realID = parts{1}; 
                
                try
                    img = imread(fullPath);
                    [template, ~, ~, descriptors] = process_fingerprint(img);
                    
                    if size(template, 1) < minPointsEnroll
                        results{end+1, 1} = thisFile;
                        results{end, 2} = realID;
                        results{end, 3} = '---';
                        results{end, 4} = 0;
                        results{end, 5} = 'איכות נמוכה';
                        continue;
                    end
                    
                    validCount = validCount + 1;
                    
                    % חיפוש במאגר (שנמצא בזיכרון)
                    bestScore = 0;
                    bestMatchName = 'לא זוהה';
                    
                    currData.minutiae = template;
                    currData.descriptors = descriptors;
                    
                    for i = 1:length(fingerprintDB)
                        dbData.minutiae = fingerprintDB(i).template;
                        if isfield(fingerprintDB(i), 'descriptors')
                            dbData.descriptors = fingerprintDB(i).descriptors;
                        else, dbData.descriptors = []; end
                        
                        [score, ~, ~] = find_best_match(dbData, currData, 0);
                        
                        if score > bestScore
                            bestScore = score;
                            if score >= PASS_THRESHOLD
                                bestMatchName = fingerprintDB(i).name;
                            end
                        end
                    end
                    
                    % בדיקת הצלחה
                    matchParts = strsplit(bestMatchName, '_');
                    matchID = matchParts{1};
                    
                    if strcmp(realID, matchID)
                        status = 'V הצלחה';
                        correctCount = correctCount + 1;
                    else
                        status = 'X שגיאה';
                    end
                    
                    results{end+1, 1} = thisFile;      
                    results{end, 2} = realID;          
                    results{end, 3} = bestMatchName;   
                    results{end, 4} = bestScore;       
                    results{end, 5} = status;          
                    
                catch err
                    results{end+1, 1} = thisFile;
                    results{end, 2} = realID;
                    results{end, 3} = 'Error';
                    results{end, 4} = 0;
                    results{end, 5} = 'שגיאה';
                end
            end
            close(wb);
            
            % חישוב אחוזי הצלחה
            if validCount > 0
                successRate = (correctCount / validCount) * 100;
            else
                successRate = 0;
            end
            
            % הצגת התוצאות
            f = figure('Name', 'תוצאות זיהוי וסטטיסטיקה', 'NumberTitle', 'off', ...
                       'Position', [100 100 650 500], 'MenuBar', 'none');
                   
            uicontrol('Style', 'text', 'Parent', f, ...
                      'String', sprintf('אחוזי הצלחה: %.2f%% (%d/%d)', successRate, correctCount, validCount), ...
                      'FontSize', 16, 'FontWeight', 'bold', 'ForegroundColor', 'blue', ...
                      'Position', [20 450 600 30]);
            
            t = uitable(f, 'Data', results, ...
                        'ColumnName', {'שם קובץ', 'זהות אמיתית', 'זוהה כ-', 'ציון', 'סטטוס'}, ...
                        'ColumnWidth', {120, 80, 120, 60, 80}, ...
                        'Position', [20 20 610 420]);
            
        % === 5. הצגת המאגר ===
        case 5
            if isempty(fingerprintDB)
                msgbox('המאגר ריק.');
            else
                listdlg('ListString', {fingerprintDB.name}, 'Name', 'רשימת משתמשים', 'ListSize', [300 400]);
            end
    end
end



% ========================================================================
% FILENAME: Image_processing.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\scripts
% ========================================================================

%% שלב 0: הגדרות נתיבים וניקוי
clc; clear; close all;
addpath('functions'); % וודא שתיקיית הפונקציות זמינה

%% שלב 1: טעינת התמונה
% וודא שהנתיב תואם לקובץ שלך
filename = 'data/DB1_B/103_5.tif'; 
img = imread(filename);

if size(img,3) == 3
    img = rgb2gray(img);
end

% נרמול לטווח 0-1
img = double(img);
img = (img - min(img(:))) / (max(img(:)) - min(img(:)));

%% שלב 2: עיבוד מקדים (Gabor Filter Pipeline)

% 1. סגמנטציה - הפרדת האצבע מהרקע
% תיקון: העלאת הסף ל-0.2 מנקה את רעשי הרקע (הבלוקים)
[normim, mask, maskind] = ridgesegment(img, 1, 0.2);

% 2. חישוב כיווניות (Orientation)
orientim = ridgeorient(normim, 1, 5, 5);

% 3. חישוב תדרים (Frequency)
[freqim, medfreq] = ridgefreq(normim, mask, orientim, 32, 5, 5, 15);

% 4. סינון גאבור (Gabor Filter)
newim = ridgefilter(normim, orientim, freqim, 0.5, 0.5, 1);

% --- תיקון קריטי: החלת המסכה ---
% זה מוחק את כל הריבועים הלבנים שנשארו ברקע
newim = newim .* mask;

%% שלב 3: בינאריזציה ודיקוק (Thinning)

% בינאריזציה (הפיכה לשחור לבן)
bw = newim > 0;

% חיבור קווים וסגירת חורים קטנים
bw = bwmorph(bw, 'bridge', inf); % גשרים קטנים
bw = bwmorph(bw, 'close');       % סגירה מורפולוגית
bw = imfill(bw, 'holes');        % מילוי חורים פנימיים

% דיקוק לרמת פיקסל אחד
skeleton = bwmorph(bw, 'thin', inf);

% --- תיקון סופי: ניקוי השלד ---
% ניקוי נקודות בודדות (רעש)
skeleton = bwmorph(skeleton, 'clean');
% הסרת "זיזים" (Spurs) - קווים קטנים שבולטים החוצה
skeleton = bwmorph(skeleton, 'spur', 5);

%% שלב 4: תצוגה
figure('Name', 'Fingerprint Process Final', 'NumberTitle', 'off');

subplot(1,3,1);
imshow(img);
title('1. מקור');

subplot(1,3,2);
imshow(newim);
title('2. אחרי Gabor (ללא רקע)');

subplot(1,3,3);
imshow(skeleton);
title('3. שלד נקי (ללא זיזים)');

imshow(~skeleton); 
title('שלד (תצוגת דיו)');

%% שלב 5 (השוואה כפולה): השלד על המקור מול השלד על המעובד

figure('Name', 'Skeleton Overlay Comparison', 'Units', 'normalized', 'Position', [0.1 0.3 0.8 0.5]);

% --- תמונה 1: השלד על התמונה המקורית ---
subplot(1,2,1);

% הכנת תמונת רקע (נרמול לטווח 0-1 לתצוגה)
bg_orig = double(img);
bg_orig = (bg_orig - min(bg_orig(:))) / (max(bg_orig(:)) - min(bg_orig(:)));
overlay_orig = cat(3, bg_orig, bg_orig, bg_orig); % המרה ל-RGB

% צביעת השלד באדום
tmp = overlay_orig(:,:,1); tmp(skeleton) = 1; overlay_orig(:,:,1) = tmp; % ערוץ אדום מלא
tmp = overlay_orig(:,:,2); tmp(skeleton) = 0; overlay_orig(:,:,2) = tmp; % איפוס ירוק
tmp = overlay_orig(:,:,3); tmp(skeleton) = 0; overlay_orig(:,:,3) = tmp; % איפוס כחול

imshow(overlay_orig);
title('1. השלד על התמונה המקורית (Original)');


% --- תמונה 2: השלד על התמונה המעובדת (אחרי Gabor) ---
subplot(1,2,2);

% הכנת תמונת רקע (נרמול לטווח 0-1 לתצוגה)
bg_enhanced = newim;
bg_enhanced = (bg_enhanced - min(bg_enhanced(:))) / (max(bg_enhanced(:)) - min(bg_enhanced(:)));
overlay_enhanced = cat(3, bg_enhanced, bg_enhanced, bg_enhanced); % המרה ל-RGB

% צביעת השלד באדום
tmp = overlay_enhanced(:,:,1); tmp(skeleton) = 1; overlay_enhanced(:,:,1) = tmp;
tmp = overlay_enhanced(:,:,2); tmp(skeleton) = 0; overlay_enhanced(:,:,2) = tmp;
tmp = overlay_enhanced(:,:,3); tmp(skeleton) = 0; overlay_enhanced(:,:,3) = tmp;

imshow(overlay_enhanced);
title('2. השלד על התמונה המעובדת (Enhanced)');

% קישור הצירים כדי שזום באחד יעשה זום גם בשני
linkaxes;



% ========================================================================
% FILENAME: run_batch_gabor.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\scripts
% ========================================================================

%% run_batch_gabor.m - עיבוד אצווה עם Gabor ב-MATLAB בלבד
clc; close all; clear;

% הוספת נתיב לפונקציות
addpath('src');

% הגדרת תיקיית שמירה
saveFolder = fullfile(pwd, 'data', 'processed_skeletons'); 
if ~exist(saveFolder, 'dir'), mkdir(saveFolder); end

% 1. בחירת קבצים
disp('אנא בחר את התמונות המקוריות לעיבוד...');
[files, path] = uigetfile({'*.tif;*.png;*.jpg;*.bmp', 'Image Files'}, ...
                           'בחר תמונות', 'MultiSelect', 'on');

if isequal(files, 0), disp('לא נבחרו קבצים.'); return; end
if ischar(files), files = {files}; end

h = waitbar(0, 'מתחיל עיבוד...');
totalFiles = length(files);

for k = 1:totalFiles
    filename = files{k};
    fullPath = fullfile(path, filename);
    [~, nameNoExt, ~] = fileparts(filename);
    
    waitbar(k/totalFiles, h, sprintf('מעבד: %s...', filename));
    
    try
        % --- שלב העיבוד (קורא לפונקציה החדשה שיצרנו) ---
        img = imread(fullPath);
        
        % הפונקציה הזו מחליפה את הסקריפט של פייתון + העיבוד הקודם
        [~, ~, ~, ~, debugData] = process_fingerprint(img, false);
        skeletonMask = debugData.skeletonImg;
        enhancedImg  = debugData.enhancedImg;
        
        % --- שמירה ---
        % שמירת השלד (נהפוך צבעים אם צריך שחור על גבי לבן ל-PNG)
        % ~skeletonMask הופך את ה-1 (רכס) ל-0 (שחור) ואת הרקע ללבן
        finalOutput = ~skeletonMask; 
        
        saveName = fullfile(saveFolder, [nameNoExt '_skeleton.png']);
        imwrite(finalOutput, saveName);
        
        % אופציונלי: שמירת התמונה המשופרת (Gabor) לצורך בדיקה
        % imwrite(enhancedImg > 0, fullfile(saveFolder, [nameNoExt '_enhanced.png']));
        
        fprintf('V הושלם: %s\n', filename);
        
    catch err
        fprintf('X שגיאה ב-%s: %s\n', filename, err.message);
    end
end

close(h);
msgbox(['הסתיים העיבוד! הקבצים נשמרו ב: ' saveFolder]);



% ========================================================================
% FILENAME: visualiz.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\scripts
% ========================================================================

%% run_visualizer.m - סקריפט לבחירת תמונה והצגת ה-Pipeline
clc; clear; close all;

% --- תיקון קריטי: הוספת תיקיית הפונקציות ל-Path ---
% הפקודה הזו אומרת למאטלב לחפש פונקציות גם בתיקיית src
if exist('src', 'dir')
    addpath(genpath('src'));
else
    warning('תיקיית src לא נמצאה במיקום הנוכחי!');
end
% --------------------------------------------------

%% === הגדרות משתמש ===
USE_FIXED_FILE = true; 

% הגדר כאן רק את שם הקובץ
FIXED_FILENAME = '103_5.tif'; 

% הגדר כאן את הנתיב לתיקייה
FIXED_FOLDER = 'C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\data\DB1_B';
%% ====================

% 1. לוגיקה לבחירת הקובץ
if USE_FIXED_FILE
    % חיבור הנתיב הארוך עם שם הקובץ
    fullPath = fullfile(FIXED_FOLDER, FIXED_FILENAME);
    
    % בדיקה שהקובץ אכן קיים
    if ~isfile(fullPath)
        % ניסיון אחרון: אולי הקובץ נמצא בתיקייה הנוכחית?
        if isfile(FIXED_FILENAME)
            fullPath = FIXED_FILENAME;
        else
            % הודעת שגיאה ברורה עם הנתיב שניסינו
            error('הקובץ לא נמצא!\nחיפשתי ב:\n%s\nוגם בתיקייה הנוכחית.', fullPath);
        end
    end
    fprintf('>> מצב אוטומטי: טוען תמונה %s\n', FIXED_FILENAME);
    
else
    % --- אופציה ב': בחירה ידנית עם חלון ---
    startPath = 'data/';
    if ~exist(startPath, 'dir'), startPath = pwd; end
    
    [fileName, pathName] = uigetfile({'*.png;*.tif;*.jpg;*.bmp', 'Fingerprint Images'}, ...
                                     'בחר תמונה לבדיקה', startPath);
    
    if isequal(fileName, 0)
        disp('לא נבחרו קבצים. יציאה.');
        return;
    end
    fullPath = fullfile(pathName, fileName);
    fprintf('>> נבחר ידנית: %s\n', fileName);
end

% 2. טעינת התמונה וביצוע העיבוד
try
    img = imread(fullPath);
    
    % 3. הפעלת העיבוד במצב ויזואליזציה
    % כעת הפונקציה תרוץ כי הוספנו את addpath('src') בהתחלה
    process_fingerprint(img, true);
    
catch err
    errordlg(['שגיאה בטעינה או בעיבוד: ' err.message]);
    rethrow(err); % הצגת השגיאה המלאה בחלון הפקודות
end



% ========================================================================
% FILENAME: process_fingerprint.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src
% ========================================================================

function [template, roiMask, rawMinutiae, descriptors] = process_fingerprint(img, do_viz)
    % process_fingerprint - גרסה משודרגת עם שיפור Gabor
    % קלט: תמונה גולמית (צבעונית או אפורה)
    % פלט: תבנית נקודות מסוננת, מסיכה, נקודות גולמיות, ודסקריפטורים
    
    if nargin < 2, do_viz = false; end
    cfg = get_config();
    
    % מבנה לדיבוג
    debug = struct();
    
    % 1. המרה לאפור ונרמול
    if size(img, 3) == 3, img = rgb2gray(img); end
    img = im2double(img);
    debug.imgGray = img;
    
    % --- שלב השיפור החדש (Gabor Enhancement) ---
    
    % 2. סגמנטציה (הפרדת האצבע מהרקע)
    [normim, mask, ~] = ridgesegment(img, cfg.gabor.blk_sze, cfg.gabor.thresh);
    roiMask = mask; % שומרים את המסיכה המדויקת שחושבה כאן
    debug.roiMask = roiMask;
    
    % 3. חישוב כיוונים (Orientation Map)
    orientim = ridgeorient(normim, cfg.gabor.grad_sigma, cfg.gabor.block_sigma, cfg.gabor.smooth_sigma);
    
    % 4. חישוב תדרים (Frequency Map)
    [freqim, ~] = ridgefreq(normim, mask, orientim, cfg.gabor.freq_blk, ...
                            cfg.gabor.freq_wind, cfg.gabor.min_wl, cfg.gabor.max_wl);
    
    % 5. שיפור תמונה (Gabor Filtering)
    % התמונה הזו חלקה וברורה הרבה יותר מהמקור
    enhancedImg = ridgefilter(normim, orientim, freqim, cfg.gabor.kx, cfg.gabor.ky, 0);
    
    % 6. בינאריזציה וניקוי
    % פלט גאבור הוא סביב ה-0. ערכים > 0 הם רכסים.
    binaryImg = enhancedImg > 0;
    binaryImg = binaryImg & roiMask; % חיתוך לפי המסיכה
    
    % ניקוי חורים קטנים שנוצרו (אופציונלי אך מומלץ)
    binaryImg = bwareaopen(binaryImg, 10);
    binaryImg = ~bwareaopen(~binaryImg, 10);
    
    debug.binaryMasked = binaryImg;
    
    % 7. יצירת שלד (Skeletonization)
    skeletonImg = bwmorph(binaryImg, 'thin', Inf);
    skeletonImg = bwmorph(skeletonImg, 'clean');
    skeletonImg = bwmorph(skeletonImg, 'diag');
    skeletonImg = bwmorph(skeletonImg, 'spur', 5); 
    
    debug.skeletonImg = skeletonImg;
    
    % --- שלב חילוץ המאפיינים (כמו בקוד הקודם) ---
    
    % 8. חילוץ נקודות (Minutiae) מהשלד הנקי
    rawMinutiae = extract_minutiae_features(skeletonImg, cfg);
    debug.rawMinutiae = rawMinutiae;
    
    % 9. סינון סופי (שוליים, צפיפות, מבנה)
    template = filter_minutiae(rawMinutiae, roiMask, cfg);
    debug.finalTemplate = template;
    
    % 10. חישוב מתארים (Descriptors)
    descriptors = compute_descriptors(template, cfg);
    
    % --- ויזואליזציה ---
    if do_viz
        visualize_pipeline(debug, cfg);
    end
end



% ========================================================================
% FILENAME: get_config.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\00_Config
% ========================================================================

function cfg = get_config()
    % get_config - קובץ הגדרות מרכזי (גרסה מתוקנת)
    
    %% 1. הגדרות מערכת וקבצים
    cfg.db_filename = 'fingerprint_database.mat';
    
    %% 2. הגדרות Gabor (שיפור תמונה מתקדם)
    cfg.gabor.blk_sze = 16;       % גודל בלוק לסגמנטציה
    cfg.gabor.thresh = 0.1;       % סף שונות להפרדת רקע
    cfg.gabor.grad_sigma = 1;     % סיגמא לחישוב נגזרות כיוון
    cfg.gabor.block_sigma = 7;    % סיגמא להחלקת כיוונים
    cfg.gabor.smooth_sigma = 7;   % החלקה סופית של שדה הכיוונים
    cfg.gabor.freq_blk = 30;      % גודל בלוק לחישוב תדר
    cfg.gabor.freq_wind = 5;      % חלון חישוב תדר
    cfg.gabor.min_wl = 5;         % אורך גל מינימלי
    cfg.gabor.max_wl = 15;        % אורך גל מקסימלי
    cfg.gabor.kx = 0.65;          % חוזק הסינון בציר X
    cfg.gabor.ky = 0.65;          % חוזק הסינון בציר Y
    
    %% 3. הגדרות עיבוד המשך ובינאריזציה
    cfg.binarize.sens = 0.5;      
    
    %% 4. הגדרות רישום ובקרת איכות (Enrollment)
    cfg.enroll.min_minutiae = 12; % מינימום נקודות לרישום
    
    %% 5. הגדרות מסיכה ועיבוד מקדים
    cfg.roi.erosion_size = 0;   
    cfg.roi.closing_size = 20;  
    
    cfg.preprocess.gauss_sigma = 0.8;       
    cfg.preprocess.bin_sensitivity = 0.65;  
    
    %% 6. חילוץ מאפיינים
    cfg.feature.descriptor_k = 5;   
    cfg.feature.angle_steps = 5;    
    
    %% 7. הגדרות סינון (Filtering)
    cfg.filter.border_margin = 25; 
    cfg.filter.min_distance = 20;  
    
    % סינון גיאומטרי
    cfg.filter.max_short_ridge_dist = 15; 
    cfg.filter.max_bridge_dist = 12; 
    cfg.filter.max_spike_dist = 8;
    cfg.filter.angle_tolerance = deg2rad(35);
    
    %% 8. הגדרות התאמה (Matching)
    cfg.match.pass_threshold = 12.0;    
    cfg.match.candidate_count = 50;     
    
    cfg.match.max_dist = 15;            
    cfg.match.max_ang_deg = 45;         
    cfg.match.max_ang_rad = deg2rad(cfg.match.max_ang_deg);
    
    %% 9. הגדרות ניקוד (Scoring)
    cfg.score.sigma_dist = 10;     
    cfg.score.sigma_ang_rad = 0.5; 
    cfg.score.sigma_desc = 45;     
end



% ========================================================================
% FILENAME: get_roi_mask.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\01_Enhancement
% ========================================================================

function mask = get_roi_mask(img)
    % get_roi_mask - מחזירה מסיכה מלאה ואטומה (ללא כרסום)
    
    cfg = get_config();
    
    % 1. זיהוי טקסטורה
    textureMap = rangefilt(img);
    level = graythresh(textureMap);
    mask = imbinarize(textureMap, level);
    
    % 2. חיבור וסגירה
    % שימוש בערך גדול (20) כדי לאחד את כל הפסים לגוש אחד
    seClose = strel('disk', cfg.roi.closing_size); 
    mask = imclose(mask, seClose);
    
    % 3. מילוי חורים (קריטי לחישוב מרחק תקין)
    mask = imfill(mask, 'holes');
    
    % 4. ניקוי רעשי רקע (השארת הגוש הגדול בלבד)
    mask = bwareafilt(mask, 1);
    
    mask = logical(mask);
end



% ========================================================================
% FILENAME: ridgefilter.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\01_Enhancement
% ========================================================================

% =========================================================================
% RIDGEFILTER - שיפור התמונה בעזרת מסנן גאבור (Gabor Filter)
% =========================================================================
% תפקיד הפונקציה בפועל:
% זהו "המנוע" של המערכת. הפונקציה בונה מסנן ייחודי לכל פיקסל בתמונה,
% בהתבסס על:
% 1. הכיוון שלו (מ-ridgeorient)
% 2. העובי שלו (מ-ridgefreq)
%
% הפעולה שהיא מבצעת:
% היא "מורחת" את הפיקסלים *רק* לאורך כיוון הרכס.
% התוצאה: "חורים" ונתקים בתוך הרכס מתמלאים (נסגרים),
% ורעש שנמצא בין הרכסים (בעמקים) נמחק.
%
% פלט: תמונה משופרת ונקייה, מוכנה לבינאריזציה ודיקוק.
% =========================================================================


function [newim] = ridgefilter(im, orient, freq, kx, ky, showfilter)
% RIDGEFILTER - Enhances fingerprint image via oriented filters
%
% Usage: [newim] = ridgefilter(im, orient, freq, kx, ky, showfilter)
%
% Arguments:  im         - Image to be processed.
%             orient     - Ridge orientation image.
%             freq       - Ridge frequency image.
%             kx, ky     - Scale factors specifying the filter sigma relative
%                          to the wavelength of the filter (suggest 0.5).
%             showfilter - An optional flag 0/1.  If set to 1 the code will
%                          display the filter being created.
%
% Returns:    newim      - The enhanced image.

    if nargin == 5; showfilter = 0; end
    
    angleInc = 3;  % Fixed angle increment between filter orientations in degrees
    im = double(im);
    [rows, cols] = size(im);
    newim = zeros(rows,cols);
    
    % Round the array of frequencies to the nearest 0.01 to reduce the
    % number of distinct frequencies we have to generate filters for.
    freq_1d = freq(:);
    ind = find(freq_1d > 0);
    freq_1d(ind) = round(freq_1d(ind)*100)/100;
    unifreqs = unique(freq_1d(ind));
    
    % Generate filters corresponding to these distinct frequencies and
    % orientations in 'angleInc' increments.
    sigmax = 0; sigmay = 0;
    sze = zeros(length(unifreqs),1);
    filters = cell(length(unifreqs), 180/angleInc);
    
    for k = 1:length(unifreqs)
        sigmax = kx/unifreqs(k);
        sigmay = ky/unifreqs(k);
        sze(k) = round(3*max(sigmax,sigmay));
        [x,y] = meshgrid(-sze(k):sze(k));
        reffilter = exp(-(x.^2/sigmax^2 + y.^2/sigmay^2)/2)...
                    .*cos(2*pi*unifreqs(k)*x);
        
        % Generate rotated versions of the filter
        for o = 1:180/angleInc
            filters{k,o} = imrotate(reffilter, -(o*angleInc+90), 'bilinear', 'crop'); 
        end
    end

    % Apply the filters to the image
    % Find indices of matrix points greater than maxsze from the image boundary
    maxsze = sze(1);
    finalind = find(freq>0);
    
    % Convert orientation matrix values from radians to an index value
    % that corresponds to round(degrees/angleInc)
    maxorientindex = round(180/angleInc);
    orientindex = round(orient/pi*180/angleInc);
    i = find(orientindex < 1);   orientindex(i) = orientindex(i)+maxorientindex;
    i = find(orientindex > maxorientindex); orientindex(i) = orientindex(i)-maxorientindex; 
    
    % Filter the image
    for k = 1:length(unifreqs)
        thisfreq = unifreqs(k);
        
        % Find where this frequency occurs in the image
        freqind = find(freq_1d == thisfreq);
        
        % Iterate through the orientation indices
        for o = 1:180/angleInc
            ind = intersect(freqind, find(orientindex(:)==o));
             
            if ~isempty(ind)
                % Extract the relevant filter
                filter = filters{k,o};
                
                % Get row and col indices
                [r, c] = ind2sub([rows,cols], ind);
                
                % Apply filter to these pixels (valid boundary check required in loops)
                % Simplification for speed: Block processing or full convolution 
                % is usually done here. For pixel-wise efficiency:
                 
                 r_valid = r(r>sze(k) & r<rows-sze(k) & c>sze(k) & c<cols-sze(k));
                 c_valid = c(r>sze(k) & r<rows-sze(k) & c>sze(k) & c<cols-sze(k));
                 
                 % Note: This loop can be slow in MATLAB. A faster way is using
                 % block processing, but this is the explicit implementation.
                 for i = 1:length(r_valid)
                     blk = im(r_valid(i)-sze(k):r_valid(i)+sze(k), c_valid(i)-sze(k):c_valid(i)+sze(k));
                     newim(r_valid(i),c_valid(i)) = sum(sum(blk.*filter));
                 end
            end
        end
    end
end



% ========================================================================
% FILENAME: ridgefreq.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\01_Enhancement
% ========================================================================

% =========================================================================
% RIDGEFREQ - חישוב תדירות הרכסים (Ridge Frequency)
% =========================================================================
% תפקיד הפונקציה בפועל:
% הפונקציה מודדת כמה "צפופים" הקווים בטביעת האצבע.
% היא לוקחת בלוקים מהתמונה, מסובבת אותם כך שהקווים יהיו אנכיים,
% ואז סופרת כמה פיקסלים יש בין פס שחור אחד לשני (אורך גל).
%
% למה זה קריטי?
% כדי שמסנן גאבור יידע איזה "רוחב" של מכחול הוא צריך כדי לצייר מחדש את הקווים.
% אם המסנן יהיה רחב מדי - הוא יחבר שני קווים סמוכים.
% אם הוא יהיה צר מדי - הוא לא יצליח לסגור חורים בתוך הקו.
%
% קלט: תמונה, מסכה, ומפת כיוונים.
% פלט: מפה של תדרים (1 חלקי המרחק בין הרכסים).
% =========================================================================



function [freqim, medianfreq] = ridgefreq(im, mask, orientim, blksze, windsze, ...
                                             minWaveLength, maxWaveLength)
% RIDGEFREQ - Estimates the local ridge frequency across a fingerprint
%
% Usage: [freqim, medianfreq] = ridgefreq(im, mask, orientim, blksze, windsze, ...
%                                         minWaveLength, maxWaveLength)
%
% Arguments:  im       - Image to be processed.
%             mask     - Mask defining ridge regions.
%             orientim - Ridge orientation image.
%             blksze   - Size of image block to use (say 32).
%             windsze  - Window length used to identify peaks (say 5).
%             minWaveLength,  maxWaveLength - Minimum and maximum ridge
%                             wavelengths, in pixels (say 5 and 15).
%
% Returns:    freqim     - An image  the same size as im with  values set to
%                          the estimated ridge spatial frequency.
%             medianfreq - Median frequency value evaluated across the
%                          fingerprint.

    [rows, cols] = size(im);
    freqim = zeros(rows, cols);
    
    for r = 1:blksze:rows-blksze+1
        for c = 1:blksze:cols-blksze+1
            blkim = im(r:r+blksze-1, c:c+blksze-1);
            blkor = orientim(r:r+blksze-1, c:c+blksze-1);
            
            freq = freqest(blkim, blkor, windsze, minWaveLength, maxWaveLength);
            freqim(r:r+blksze-1, c:c+blksze-1) = freq;
        end
    end
    
    % Mask out frequencies calculated for non-ridge regions
    freqim = freqim .* mask;
    
    % Generate median frequency
    medianfreq = median(freqim(freqim > 0));
end

% פונקציית עזר פנימית לחישוב תדר בבלוק בודד
function freq = freqest(im, orientim, windsze, minWaveLength, maxWaveLength)
    [rows, cols] = size(im);
    
    % Find mean orientation within the block
    cosorient = mean(cos(2*orientim(:)));
    sinorient = mean(sin(2*orientim(:)));
    orient = atan2(sinorient, cosorient)/2;
    
    % Rotate the image block so that the ridges are vertical
    rotim = imrotate(im, orient/pi*180 + 90, 'bicubic', 'crop');
    
    % Sum down the columns to get a projection of the grey values
    proj = sum(rotim);
    
    % Find peaks in projected grey values
    dilation = ordfilt2(proj, windsze, ones(1,windsze));
    maxpts = (dilation == proj) & (proj > mean(proj));
    maxind = find(maxpts);
    
    % Determine spatial frequency of ridges
    if length(maxind) < 2
        freq = 0;
    else
        NoOfPeaks = length(maxind);
        waveLength = (maxind(end) - maxind(1)) / (NoOfPeaks - 1);
        if waveLength >= minWaveLength && waveLength <= maxWaveLength
            freq = 1/waveLength;
        else
            freq = 0;
        end
    end
end



% ========================================================================
% FILENAME: ridgeorient.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\01_Enhancement
% ========================================================================

% =========================================================================
% RIDGEORIENT - חישוב מפת כיוונים (Orientation Map)
% =========================================================================
% תפקיד הפונקציה בפועל:
% הפונקציה עוברת על כל נקודה בתמונה ומחשבת את ה"זווית" של הרכס באותו מקום.
% היא משתמשת בנגזרות (Gradients) כדי להבין לאן הקו "זורם".
%
% למה זה קריטי?
% מסנן גאבור (בשלב הבא) חייב לדעת את הזווית הזו כדי להחליק את התמונה
% *עם* כיוון הקו (כדי לחבר שברים) ולא *נגד* כיוון הקו (שזה ימרח אותו).
%
% קלט: תמונה מנורמלת (מ-ridgesegment).
% פלט: מטריצה באותו גודל כמו התמונה, המכילה זוויות (ברדיאנים) לכל פיקסל.
% =========================================================================



function [orientim] = ridgeorient(im, gradientsigma, blocksigma, orientsmoothsigma)
% RIDGEORIENT - Estimates the local orientation of ridges in a fingerprint
%
% Usage:  [orientim] = ridgeorient(im, gradientsigma, blocksigma, ...
%                                    orientsmoothsigma)
%
% Arguments:  im                - A normalised input image.
%             gradientsigma     - Sigma of the derivative of Gaussian
%                                 used to compute image gradients.
%             blocksigma        - Sigma of the Gaussian weighting used to
%                                 sum the gradient moments.
%             orientsmoothsigma - Sigma of the Gaussian used to smooth
%                                 the final orientation vector field.
% 
% Returns:    orientim          - The orientation image in radians.
%                                 Orientation values are between 0 and pi.

    [rows, cols] = size(im);
    
    % Calculate image gradients.
    sze = fix(6*gradientsigma);   if ~mod(sze,2); sze = sze+1; end
    f = fspecial('gaussian', sze, gradientsigma); % Generate Gaussian filter.
    [fx, fy] = gradient(f);                       % Gradient of Gausian.
    
    Gx = imfilter(im, fx, 'symmetric', 'conv');
    Gy = imfilter(im, fy, 'symmetric', 'conv');
    
    % Estimate the local ridge orientation at each point by finding the
    % principal axis of variation in the image gradients.
    Gxx = Gx.^2;       % Covariance data for the image gradients
    Gxy = Gx.*Gy;
    Gyy = Gy.^2;
    
    % Now smooth the covariance data to perform a weighted summation of the
    % data.
    sze = fix(6*blocksigma);   if ~mod(sze,2); sze = sze+1; end
    f = fspecial('gaussian', sze, blocksigma);
    Gxx = imfilter(Gxx, f, 'symmetric', 'conv');
    Gxy = 2*imfilter(Gxy, f, 'symmetric', 'conv');
    Gyy = imfilter(Gyy, f, 'symmetric', 'conv');
    
    % Analytic solution of principal direction
    denom = sqrt(Gxy.^2 + (Gxx - Gyy).^2) + eps;
    sin2theta = Gxy./denom;            % Sine and cosine of doubled angles
    cos2theta = (Gxx - Gyy)./denom;
    
    % Smooth the orientation vector field using a low pass filter
    if orientsmoothsigma
        sze = fix(6*orientsmoothsigma);   if ~mod(sze,2); sze = sze+1; end
        f = fspecial('gaussian', sze, orientsmoothsigma);
        cos2theta = imfilter(cos2theta, f, 'symmetric', 'conv');
        sin2theta = imfilter(sin2theta, f, 'symmetric', 'conv');
    end
    
    % Calculate the orientation angle
    orientim = pi/2 + atan2(sin2theta, cos2theta)/2;
end



% ========================================================================
% FILENAME: ridgesegment.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\01_Enhancement
% ========================================================================

function [normim, mask, maskind] = ridgesegment(im, blksze, thresh)
% =========================================================================
% RIDGESEGMENT - הפרדת טביעת האצבע מהרקע (Segmentation)
% =========================================================================
% תפקיד הפונקציה בפועל:
% 1. נרמול התמונה: מאזנת את הבהירות והניגודיות כדי שהחישובים יהיו אחידים.
% 2. חישוב שונות (Variance): מחלקת את התמונה לבלוקים (למשל 16x16).
%    - אם השונות בבלוק גבוהה -> יש שם קווים (רכסים) -> זה חלק מהאצבע.
%    - אם השונות נמוכה -> האזור חלק -> זה רקע ריק.
% 3. יצירת מסכה (Mask): מחזירה מפה של 0 ו-1 שאומרת לנו איפה האצבע נמצאת.
%
% קלט: תמונה גולמית.
% פלט: תמונה מנורמלת + מסכה (Mask) שמחקה את הרקע המיותר.
% =========================================================================

    
    im = double(im);
    [rows, cols] = size(im);  
    
    % 1. נרמול ראשוני
    im = (im - mean(im(:))) / std(im(:));
    
    % 2. חישוב שונות לכל בלוק (זיהוי אזורי האצבע)
    stddevim = zeros(rows,cols);
    for r = 1:blksze:rows-blksze+1
        for c = 1:blksze:cols-blksze+1
            block = im(r:r+blksze-1, c:c+blksze-1);
            stddevim(r:r+blksze-1, c:c+blksze-1) = std(block(:));
        end
    end
    
    % 3. יצירת מסיכה (1=אצבע, 0=רקע)
    mask = stddevim > thresh;
    
    % --- תוספת חדשה: חיתוך השוליים (Cropping) ---
    % אנו בודקים אלו שורות ועמודות מכילות מידע (1)
    rows_with_data = any(mask, 2);
    cols_with_data = any(mask, 1);
    
    % מציאת הגבולות (האינדקס הראשון והאחרון שיש בו אצבע)
    r1 = find(rows_with_data, 1, 'first');
    r2 = find(rows_with_data, 1, 'last');
    c1 = find(cols_with_data, 1, 'first');
    c2 = find(cols_with_data, 1, 'last');
    
    % ביצוע החיתוך בפועל (רק אם נמצא מידע)
    if ~isempty(r1) && ~isempty(c1)
        % הוספת "ריפוד" קטן של 2 פיקסלים שלא יהיה צפוף מדי (אופציונלי)
        padding = 2;
        r1 = max(1, r1 - padding); r2 = min(rows, r2 + padding);
        c1 = max(1, c1 - padding); c2 = min(cols, c2 + padding);
        
        % חיתוך התמונה והמסיכה
        im = im(r1:r2, c1:c2);
        mask = mask(r1:r2, c1:c2);
    end
    % ---------------------------------------------
    
    % 4. נרמול סופי (מבוסס רק על אזור האצבע החתוך)
    maskind = find(mask);
    if ~isempty(maskind)
        im = (im - mean(im(maskind))) / std(im(maskind));
    end
    
    normim = im;
end



% ========================================================================
% FILENAME: compute_descriptors.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\02_Extraction
% ========================================================================

function descriptors = compute_descriptors(minutiae, cfg)
    % compute_descriptors - יצירת מתאר (Descriptor) לכל נקודת מינושה
    % גרסה עצמאית (ללא צורך ב-Statistics Toolbox)
    
    % קלט: 
    %   minutiae - מטריצה N x 4 (x, y, type, theta)
    %   cfg      - מבנה ההגדרות (מכיל את feature.descriptor_k)
    % פלט: 
    %   descriptors - מטריצה N x K
    
    % בדיקת קלט (הגנה למקרה ששכחנו להגדיר בקונפיג)
    if nargin < 2 || ~isfield(cfg.feature, 'descriptor_k')
        kNeighbors = 5; % ברירת מחדל
    else
        kNeighbors = cfg.feature.descriptor_k;
    end
    
    numMinutiae = size(minutiae, 1);
    
    % אם אין מספיק נקודות, נחזיר מטריצה של אפסים
    % (חייבים לפחות K+1 נקודות כי הנקודה עצמה לא נחשבת שכן של עצמה)
    if numMinutiae <= kNeighbors
        descriptors = zeros(numMinutiae, kNeighbors);
        return;
    end
    
    % חילוץ קואורדינטות (X, Y)
    x = minutiae(:, 1);
    y = minutiae(:, 2);
    
    % --- חישוב מטריצת מרחקים ידני (במקום pdist) ---
    dx = x - x.'; 
    dy = y - y.';
    
    % מרחק אוקלידי
    distMatrix = sqrt(dx.^2 + dy.^2);
    
    % --- יצירת המתארים ---
    descriptors = zeros(numMinutiae, kNeighbors);
    
    for i = 1:numMinutiae
        % שליפת המרחקים עבור הנקודה הנוכחית
        dists = distMatrix(i, :);
        
        % מיון המרחקים מהקטן לגדול
        sortedDists = sort(dists, 'ascend');
        
        % לוקחים את ה-K שכנים הקרובים 
        % (מתחילים מאינדקס 2, כי אינדקס 1 הוא המרחק 0 של הנקודה לעצמה)
        nearestDists = sortedDists(2 : kNeighbors + 1);
        
        % שמירה
        descriptors(i, :) = nearestDists;
    end
end



% ========================================================================
% FILENAME: extract_minutiae_features.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\02_Extraction
% ========================================================================

function minutiaeData = extract_minutiae_features(skeletonImage, cfg)
    % extract_minutiae_features - גרסה מואצת (Optimized)
    % משתמשת בפונקציות C++ מובנות של MATLAB לזיהוי מהיר של נקודות
    
    %% 1. נרמול ושיפור השלד
    skeletonImage = logical(skeletonImage);
    
    % בדיקת היפוך צבעים (אם הרקע לבן - נהפוך אותו)
    if sum(skeletonImage(:)) > numel(skeletonImage)/2
        skeletonImage = ~skeletonImage;
    end
    
    % ניקוי ודיקוק (כמו במקור)
    skeletonImage = bwmorph(skeletonImage, 'thin', Inf);
    skeletonImage = bwmorph(skeletonImage, 'clean'); % מסיר פיקסלים בודדים
    skeletonImage = bwmorph(skeletonImage, 'spur', 5); % מסיר קווים קצרצרים (זיזים)
    
    %% 2. זיהוי טופולוגי מהיר (במקום Crossing Number ידני)
    % הפונקציה bwmorph רצה ב-C++ ומבצעת את חישוב ה-CN לכל התמונה בבת אחת
    
    % מציאת סיומות (End points)
    bw_endings = bwmorph(skeletonImage, 'endpoints');
    [r_end, c_end] = find(bw_endings);
    
    % מציאת פיצולים (Branch points)
    bw_branches = bwmorph(skeletonImage, 'branchpoints');
    [r_bif, c_bif] = find(bw_branches);
    
    %% 3. איחוד המידע וחישוב זוויות
    numEnd = length(r_end);
    numBif = length(r_bif);
    
    % הקצאה מראש מדויקת (אין צורך בניחוש גודל)
    minutiaeData = zeros(numEnd + numBif, 4);
    
    % --- עיבוד סיומות (Type = 1) ---
    for i = 1:numEnd
        % חישוב זווית רק לנקודות שנמצאו
        angle = calculate_orientation_reliable(skeletonImage, r_end(i), c_end(i), cfg);
        minutiaeData(i, :) = [c_end(i), r_end(i), 1, angle];
    end
    
    % --- עיבוד פיצולים (Type = 3) ---
    for i = 1:numBif
        angle = calculate_orientation_reliable(skeletonImage, r_bif(i), c_bif(i), cfg);
        
        % הערה: המיקום של branchpoints ב-bwmorph הוא לפעמים פיקסל אחד ליד
        % הצומת האמיתי, אבל זה זניח לרוב השימושים.
        minutiaeData(numEnd + i, :) = [c_bif(i), r_bif(i), 3, angle];
    end
    
    % (אין צורך ב"חיתוך סופי" כי גודל המערך ידוע מראש ומדויק)
end

%% פונקציית עזר לחישוב זווית (ללא שינוי, כפי שביקשת)
function angle = calculate_orientation_reliable(img, r, c, cfg)
    % קבלת מספר הצעדים מהקונפיגורציה
    steps = cfg.feature.angle_steps;
    
    path_r = zeros(steps + 2, 1); 
    path_c = zeros(steps + 2, 1);
    
    path_r(1) = r; path_c(1) = c;
    
    for k = 1:steps
        curr_r = path_r(k); curr_c = path_c(k);
        foundNeighbor = false;
        
        for dr = -1:1
            for dc = -1:1
                if dr==0 && dc==0, continue; end
                nr = curr_r + dr; nc = curr_c + dc;
                
                [H, W] = size(img);
                if nr < 1 || nc < 1 || nr > H || nc > W, continue; end
                
                if img(nr, nc) == 1
                    if k > 1 && nr == path_r(k-1) && nc == path_c(k-1), continue; end
                    path_r(k+1) = nr; path_c(k+1) = nc;
                    foundNeighbor = true; break;
                end
            end
            if foundNeighbor, break; end
        end
        if ~foundNeighbor, break; end
    end
    
    last_idx = find(path_r ~= 0, 1, 'last');
    
    if last_idx > 1
        dy = path_r(last_idx) - path_r(1);
        dx = path_c(last_idx) - path_c(1);
        angle = atan2(dy, dx);
    else
        angle = 0;
    end
end



% ========================================================================
% FILENAME: filter_minutiae.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\02_Extraction
% ========================================================================

function cleanList = filter_minutiae(minutiaeList, roiMask, cfg)
    % filter_minutiae - מסנן רעשים: שוליים, צפיפות, שברים, גשרים וקוצים.
    
    if isempty(minutiaeList)
        cleanList = [];
        return;
    end
    
    % --- שלב 1: טיפול באפקט הגבול (Boundary Effects) ---
    margin = cfg.filter.border_margin; 
    maskFilled = imfill(roiMask, 'holes');
    distMap = bwdist(~maskFilled);
    
    X = round(minutiaeList(:, 1));
    Y = round(minutiaeList(:, 2));
    [rows, cols] = size(distMap);
    
    X = max(1, min(X, cols));
    Y = max(1, min(Y, rows));
    
    indices = sub2ind([rows, cols], Y, X);
    
    % מחיקת נקודות הקרובות מדי לקצה התמונה
    keep_mask = distMap(indices) > margin;
    currentList = minutiaeList(keep_mask, :);
    
    if isempty(currentList), cleanList = []; return; end

    % --- שלב 2: סינון גיאומטרי מבני (Structural Post-processing) ---
    numPts = size(currentList, 1);
    to_remove = false(numPts, 1);
    
    shortRidgeDistSq = cfg.filter.max_short_ridge_dist^2; 
    bridgeDistSq     = cfg.filter.max_bridge_dist^2;          
    spikeDistSq      = cfg.filter.max_spike_dist^2; 
    angTol           = cfg.filter.angle_tolerance;
    
    for i = 1:numPts
        if to_remove(i), continue; end
        
        type1 = currentList(i, 3);
        x1 = currentList(i, 1); y1 = currentList(i, 2); ang1 = currentList(i, 4);
        
        for j = (i+1):numPts
            if to_remove(j), continue; end
            
            type2 = currentList(j, 3);
            x2 = currentList(j, 1); y2 = currentList(j, 2); ang2 = currentList(j, 4);
            
            distSq = (x1-x2)^2 + (y1-y2)^2;
            
            % 1. זיהוי שבר/אי (שתי סיומות קרובות הפונות זו לזו)
            if type1 == 1 && type2 == 1
                if distSq < shortRidgeDistSq
                    angleDiff = abs(mod(ang1 - ang2 + pi, 2*pi) - pi); 
                    if abs(angleDiff - pi) < angTol || abs(angleDiff + pi) < angTol 
                        to_remove(i) = true; to_remove(j) = true;
                        break; 
                    end
                end
            
            % 2. זיהוי גשר (שני פיצולים קרובים)
            elseif type1 == 3 && type2 == 3
                if distSq < bridgeDistSq
                    to_remove(i) = true; to_remove(j) = true;
                    break; 
                end
                
            % 3. זיהוי קוץ/Spike (סיומת ופיצול קרובים ומחוברים)
            elseif (type1 == 1 && type2 == 3) || (type1 == 3 && type2 == 1)
                if distSq < spikeDistSq
                    to_remove(i) = true; to_remove(j) = true;
                    break;
                end
            end
        end
    end
    
    currentList(to_remove, :) = [];
    
    % --- שלב 3: ניקוי צפיפות סופי ---
    if ~isempty(currentList)
        minDistSq = cfg.filter.min_distance^2;
        [~, sortIdx] = sort(currentList(:, 2)); 
        currentList = currentList(sortIdx, :);
        
        numPts = size(currentList, 1);
        keep = true(numPts, 1);
        
        for i = 1:numPts
            if ~keep(i), continue; end
            distsSq = (currentList(:,1) - currentList(i,1)).^2 + ...
                      (currentList(:,2) - currentList(i,2)).^2;
            too_close = (distsSq < minDistSq) & (distsSq > 0);
            keep(too_close) = false;
        end
        cleanList = currentList(keep, :);
    else
        cleanList = [];
    end
end



% ========================================================================
% FILENAME: find_best_match.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\03_Matching
% ========================================================================

function [finalScore, bestAlignedInput, isMatch] = find_best_match(templateData, inputData, manualThreshold)
    % find_best_match - השוואה גיאומטרית וחישוב ציון התאמה משוקלל (Optimized)
    
    T_pts = templateData.minutiae;
    T_desc = templateData.descriptors;
    I_pts = inputData.minutiae;
    I_desc = inputData.descriptors;
    
    cfg = get_config();
    scoreThreshold = cfg.match.pass_threshold;
    if nargin >= 3 && manualThreshold > 0, scoreThreshold = manualThreshold; end
    
    % בדיקת שפיות: אם אין מספיק נקודות, אין טעם להשוות
    if size(T_pts,1) < 5 || size(I_pts,1) < 5
        finalScore = 0; bestAlignedInput=[]; isMatch=false; return;
    end
    
    angThr = cfg.match.max_ang_rad;
    sigmaDist = cfg.score.sigma_dist;
    sigmaDesc = cfg.score.sigma_desc;
    
    % --- שלב 1: מציאת מועמדים ליישור (Alignment Candidates) ---
    NI = size(I_pts, 1); NT = size(T_pts, 1);
    
    % חישוב מרחק בין הדסקריפטורים של כל הנקודות
    diffMat = zeros(NI, NT);
    for i = 1:NI
        d = I_desc(i,:) - T_desc; 
        diffMat(i,:) = sqrt(sum(d.^2, 2));
    end
    
    % בחירת הזוגות הסבירים ביותר להתחלת היישור
    numCandidates = min(cfg.match.candidate_count, NI * NT);
    [~, sortIdx] = sort(diffMat(:), 'ascend');
    [candidateI, candidateJ] = ind2sub([NI, NT], sortIdx(1:numCandidates));
    
    bestScore = 0;
    bestAlignedInput = [];
    
    % --- שלב 2: לולאת יישור ובדיקה ---
    for k = 1:numCandidates
        i = candidateI(k);
        j = candidateJ(k);
        
        % חישוב פרמטרי היישור (הזזה וסיבוב) לפי הזוג הנוכחי
        dTheta = T_pts(j,4) - I_pts(i,4);
        c = cos(dTheta); s = sin(dTheta);
        rotMat = [c -s; s c];
        
        % ביצוע היישור על כל נקודות הקלט
        centeredI = I_pts(:,1:2) - I_pts(i,1:2);
        rotatedI = centeredI * rotMat';
        alignedI = rotatedI + T_pts(j,1:2);
        
        % יישור הזוויות
        alignedAng = mod(I_pts(:,4) + dTheta + pi, 2*pi) - pi;
        
        % מציאת השכן הקרוב ביותר במאגר לכל נקודה מיושרת
        % (אופטימיזציה קטנה: אין צורך במטריצה מלאה, עושים שורה שורה)
        dists = zeros(NI, 1);
        idx = zeros(NI, 1);
        RefCoords = T_pts(:, 1:2);
        
        for q = 1:NI
            diffs = RefCoords - alignedI(q, :);
            dsSq = sum(diffs.^2, 2); 
            [minValSq, minIdx] = min(dsSq);
            dists(q) = sqrt(minValSq);
            idx(q) = minIdx;
        end
        
        % סינון ראשוני לפי מרחק מקסימלי מותר
        valid = dists < cfg.match.max_dist;
        
        % דורשים מינימום 3 נקודות תואמות כדי להתייחס לתוצאה ברצינות
        if sum(valid) >= 3
            matchedIdxInput = find(valid);
            matchedIdxDb = idx(valid);
            
            % בדיקה שנייה: התאמת זווית וסוג מינושיה
            angDiffs = abs(mod(alignedAng(matchedIdxInput) - T_pts(matchedIdxDb,4) + pi, 2*pi) - pi);
            typeMatch = (I_pts(matchedIdxInput,3) == T_pts(matchedIdxDb,3));
            
            goodMatches = (angDiffs < angThr) & typeMatch;
            numGoodMatches = sum(goodMatches);
            
            % דרושות לפחות 3 התאמות חזקות (כולל זווית וסוג) כדי לחשב ניקוד
            if numGoodMatches >= 3
                % --- חישוב הציון המשופר ---
                
                % 1. חישוב איכות גיאומטרית (לפי מרחק)
                geomScore = sum(exp(-dists(valid(goodMatches)).^2 / (2*sigmaDist^2)));
                
                % 2. חישוב איכות דסקריפטורים (לפי דמיון סביבתי)
                linIdx = sub2ind([NI, NT], matchedIdxInput(goodMatches), matchedIdxDb(goodMatches));
                descVals = diffMat(linIdx);
                descScore = sum(exp(-descVals.^2 / (2*sigmaDesc^2)));
                
                % 3. שקלול סופי:
                % avgQuality: מדד בין 0 ל-1 שמייצג כמה ה"פיט" (Fit) מדויק
                avgQuality = (geomScore + descScore) / (2 * numGoodMatches);
                
                % === השינוי בנוסחה ===
                % הנוסחה הישנה הסתמכה על matchRatio שהעניש חיתוכים חלקיים.
                % הנוסחה החדשה: (איכות * כמות) * פקטור לוגריתמי
                
                % פקטור בונוס: מעודד כמות גדולה של נקודות בצורה מתונה (Log scale)
                % הוספנו +1 כדי שגם עבור מעט נקודות זה לא יאפס את הציון
                quantityFactor = 1 + log10(numGoodMatches); 
                
                % הציון הסופי:
                % avgQuality * numGoodMatches = הסכום האפקטיבי של הנקודות הטובות
                % כפול ה-quantityFactor נותן בונוס על אמינות סטטיסטית
                % כפול 2.5 כדי להביא את המספרים לטווח דומה למה שהוגדר ב-CONFIG (סביב 10-20 להצלחה)
                currentScore = (avgQuality * numGoodMatches) * quantityFactor * 2.5;
                
                if currentScore > bestScore
                    bestScore = currentScore;
                    bestAlignedInput = [alignedI, I_pts(:,3), alignedAng];
                end
            end
        end
    end
    
    finalScore = bestScore;
    isMatch = (finalScore >= scoreThreshold);
end



% ========================================================================
% FILENAME: transform_minutiae.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\03_Matching
% ========================================================================

function transformedList = transform_minutiae(minutiaeList, dTheta, dX, dY)
    % transform_minutiae - מבצעת מניפולציה גיאומטרית על רשימת נקודות
    % קלט: רשימת נקודות, זווית סיבוב (רדיאנים), והזזה ב-X וב-Y
    
    if isempty(minutiaeList)
        transformedList = [];
        return;
    end
    
    transformedList = minutiaeList; % מעתיקים את המבנה
    
    c = cos(dTheta);
    s = sin(dTheta);
    
    % חישוב וקטורי מהיר (בלי לולאות)
    X = minutiaeList(:, 1);
    Y = minutiaeList(:, 2);
    Angles = minutiaeList(:, 4);
    
    % 1. נוסחת הסיבוב (סביב הראשית 0,0)
    X_rot = X * c - Y * s;
    Y_rot = X * s + Y * c;
    
    % 2. הוספת ההזזה
    transformedList(:, 1) = X_rot + dX;
    transformedList(:, 2) = Y_rot + dY;
    
    % 3. עדכון הזווית של המינוציה עצמה (גם היא מסתובבת)
    % שימוש ב-mod כדי לשמור על טווח -pi עד pi
    transformedList(:, 4) = mod(Angles + dTheta + pi, 2*pi) - pi;
end



% ========================================================================
% FILENAME: add_user_to_db.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\04_Database
% ========================================================================

function add_user_to_db(fname, name, dataStruct, path)
    % add_user_to_db - מוסיפה משתמש חדש לקובץ הנתונים
    % Inputs:
    %   fname:      שם קובץ ה-MAT של המאגר
    %   name:       שם המשתמש להוספה
    %   dataStruct: מבנה המכיל minutiae ו-descriptors
    %   path:       נתיב התמונה המקורית (לרפרנס)
    
    if isfile(fname)
        load(fname, 'fingerprintDB');
        % בדיקת תאימות לאחור (הוספת שדה חסר אם צריך)
        if ~isfield(fingerprintDB, 'descriptors')
             [fingerprintDB(:).descriptors] = deal([]); 
        end
    else
        % יצירת מאגר חדש אם לא קיים
        fingerprintDB = struct('name', {}, 'template', {}, 'descriptors', {}, 'imagePath', {});
    end
    
    % יצירת רשומה חדשה
    newEntry.name = name;
    newEntry.template = dataStruct.minutiae;       
    newEntry.descriptors = dataStruct.descriptors; 
    newEntry.imagePath = path;
    
    % הוספה למערך ושמירה
    fingerprintDB(end+1) = newEntry;
    save(fname, 'fingerprintDB');
    
    msgbox(['המשתמש ' name ' נשמר בהצלחה!'], 'אישור');
end



% ========================================================================
% FILENAME: visualize_match_result.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\05_Visualization
% ========================================================================

function visualize_match_result(img, dbTemp, alignedInput, name, score)
    % visualize_match_result - מציגה גרפית את תוצאת ההתאמה
    % Inputs:
    %   img:          התמונה המקורית של הנבדק
    %   dbTemp:       הנקודות של המשתמש מהמאגר (אדום)
    %   alignedInput: הנקודות של הנבדק אחרי יישור (ירוק)
    %   name:         שם המזוהה
    %   score:        ציון ההתאמה
    
    figure('Name', 'תוצאת זיהוי', 'NumberTitle', 'off');
    imshow(img); hold on;
    
    titleString = sprintf('Match Found: %s (Score: %.2f)', name, score);
    title(titleString, 'FontSize', 12, 'Color', 'b');
    
    if ~isempty(dbTemp) && ~isempty(alignedInput)
        % נקודות מהמאגר (המטרה) - אדום
        h1 = plot(dbTemp(:,1), dbTemp(:,2), 'ro', 'LineWidth', 2, 'MarkerSize', 8, 'DisplayName', 'Database');
        
        % נקודות מהקלט (אחרי שסובבנו אותן) - ירוק
        h2 = plot(alignedInput(:,1), alignedInput(:,2), 'g+', 'LineWidth', 2, 'MarkerSize', 8, 'DisplayName', 'Input (Aligned)');
        
        % קו מחבר בין נקודות קרובות (ויזואליזציה של ההתאמה)
        % (אופציונלי - עוזר לראות מי התאים למי)
        for i = 1:size(alignedInput, 1)
            % מחפש את הנקודה הקרובה ביותר במאגר
            dists = sum((dbTemp(:,1:2) - alignedInput(i,1:2)).^2, 2);
            [minD, idx] = min(dists);
            if minD < 100 % אם הן קרובות (מרחק < 10 פיקסלים)
                plot([alignedInput(i,1) dbTemp(idx,1)], ...
                     [alignedInput(i,2) dbTemp(idx,2)], 'y-', 'LineWidth', 1);
            end
        end
        
        legend([h1, h2], 'Location', 'best');
    end
    
    hold off;
end



% ========================================================================
% FILENAME: visualize_pipeline.m
% PATH:     C:\Users\User\OneDrive - ac.sce.ac.il\מסמכים\MATLAB\fingerprint matlab\src\05_Visualization
% ========================================================================

function visualize_pipeline(data, cfg)
    % visualize_pipeline - מציג את שלבי האלגוריתם (גרסה עם שלד ברקע)
    
    if nargin < 2
        cfg = get_config(); 
    end
    
    figure('Name', 'Fingerprint Pipeline: Skeleton View', 'Units', 'normalized', 'Position', [0 0.1 1 0.8]);
    
    % 1. מקור
    subplot(2, 4, 1); 
    imshow(data.imgGray); 
    title('1. מקור (אפור)', 'FontSize', 12);
    
    % 2. מסיכה (ROI)
    subplot(2, 4, 2); 
    imshow(data.roiMask); 
    title('2. מסיכה (Segmentation)', 'FontSize', 12);
    
    % 3. בינארי (אחרי Gabor)
    subplot(2, 4, 3); 
    imshow(data.binaryMasked); 
    title('3. בינארי (Gabor Filtered)', 'FontSize', 12);
    
    % 4. שלד
    subplot(2, 4, 4); 
    imshow(data.skeletonImg); 
    title('4. שלד (Thinned)', 'FontSize', 12);
    
    % --- שינוי: תצוגה על גבי שלד הפוך (שחור על לבן) ---
    
    % 5. גולמי
    subplot(2, 4, 5); 
    % השימוש ב- (~) הופך שחור ללבן ולהפך
    imshow(~data.skeletonImg); hold on; 
    
    rawPts = data.rawMinutiae;
    if ~isempty(rawPts)
        % נקודות כחולות
        plot(rawPts(:,1), rawPts(:,2), 'b.', 'MarkerSize', 8); 
    end
    title(['5. גולמי על שלד (' num2str(size(rawPts,1)) ')'], 'FontSize', 12);
    
    % 6. סופי (סינון)
    finalPts = data.finalTemplate;
    subplot(2, 4, 6); 
    imshow(~data.skeletonImg); hold on; % גם כאן: שלד שחור על לבן
    
    % --- ציור "האזור הבטוח" ---
    margin = cfg.filter.border_margin;
    maskFilled = imfill(data.roiMask, 'holes');
    distMap = bwdist(~maskFilled);
    safeZone = distMap > margin;
    
    boundaries = bwboundaries(safeZone);
    if ~isempty(boundaries)
        for k = 1:length(boundaries)
            b = boundaries{k};
            % שיניתי למגנטה (m) כי תכלת (c) לא רואים טוב על לבן
            plot(b(:,2), b(:,1), 'm--', 'LineWidth', 1); 
        end
    end
    
    % --- ציור הנקודות הסופיות ---
    if ~isempty(finalPts)
        % סיומות (Endings) - עיגול אדום
        termIdx = finalPts(:,3) == 1;
        if any(termIdx)
            plot(finalPts(termIdx, 1), finalPts(termIdx, 2), 'ro', 'LineWidth', 1.5, 'MarkerSize', 6);
        end
        
        % פיצולים (Bifurcations) - ריבוע ירוק
        bifIdx = finalPts(:,3) == 3;
        if any(bifIdx)
            plot(finalPts(bifIdx, 1), finalPts(bifIdx, 2), 'gs', 'LineWidth', 1.5, 'MarkerSize', 6);
        end
    end
    title(['6. סופי על שלד (' num2str(size(finalPts,1)) ')'], 'FontSize', 12);
    
    % 7. כיוונים (אוריינטציה)
    subplot(2, 4, 7); 
    imshow(~data.skeletonImg); hold on; % שלד שחור על לבן
    if ~isempty(finalPts)
        % ציור חצים קטנים
        quiver(finalPts(:,1), finalPts(:,2), ...
               cos(finalPts(:,4))*10, -sin(finalPts(:,4))*10, ...
               0, 'b', 'LineWidth', 1.2); % חצים בכחול
    end
    title('7. כיוונים', 'FontSize', 12);
    
    % 8. סיכום טקסטואלי
    subplot(2, 4, 8); axis off;
    
    minRequired = 12;
    numPoints = size(finalPts, 1);
    
    if numPoints >= minRequired
        statusColor = 'g'; 
        statusText = '✅ איכות טובה';
    elseif numPoints >= 8
        statusColor = [1 0.5 0]; 
        statusText = '⚠️ גבולי';
    else
        statusColor = 'r'; 
        statusText = '❌ נכשל';
    end
    
    text(0.5, 0.7, statusText, 'Color', statusColor, 'FontSize', 16, 'HorizontalAlignment', 'center', 'FontWeight', 'bold');
    text(0.5, 0.5, sprintf('נמצאו %d נקודות', numPoints), 'Color', 'k', 'FontSize', 12, 'HorizontalAlignment', 'center');
    text(0.5, 0.3, 'תצוגה על גבי שלד נקי', 'Color', [0.5 0.5 0.5], 'FontSize', 10, 'HorizontalAlignment', 'center');
end



